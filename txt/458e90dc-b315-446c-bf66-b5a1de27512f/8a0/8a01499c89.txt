id: 8a01499c89
标题：马克思的数学手稿（续）
日期：1881-0-0
是否是时间段：false
作者：马克思
来源：
标签：文章
书籍：自然辩证法一九七四年第三期
书籍作者：恩格斯，人民出版社1971年版

正文：
马克思的数学手稿（续）

微分演算的历史发展过程八

1）神秘的微分演算。∞，=+，-开始就变为∞=+d或+，其中dc是通过形而上学的解释来假定的。先是d存在，然后对它进行解释。

于是也就有y=3+dy或y=y+y。从这个任意的假定，就得出这样的结论：为了得到正确的结果，我们在二项式∞+4或+的展开中，必须把例如与一阶导函数一起获得的、用和4表达的那些项魔术般地丢掉，等等，等等。由于在实际建立微分演算的时候，是从上述结果出发的，也就是从那些预料到的、不是推导得来而是用解释来假定的微分元出发的，所以符号

或也是为这种解释所预料到的。

或t微系数dx

如果的增量=4，而依赖于它的变数的增量=4y，那末

△y表示∞和9的增量之比。至于 4出现在分母中，不言而喻，即自变数的增量出现在分母中而不是反过来出现在分子中，这是因为微分形式演化的最后结果本身，即微分，也是一开始就由那些假定的微分元所给定的缘故。

如果我取因变数y和自变数的最简单的关系，即y=，那①马克思在论微分》手稿中曾指出，接下去要论述“微分演算的历史发展过程”。这次继续刊登的就是这方面的部分手稿内容，包括：微分演算的历史发展过程》，初稿》，《续稿和《达兰贝尔方法分析。末我知道dy=dc或y=。但是由于我要找自变数的导函数，在这里它=c，所以我必须用或d去除两边，因而

=1。dy..一或

dx所以我一下子就全都知道，在符号微系数中自变数的增量必须出现在分母中而不是出现在分子中。

但从的二次幂函数开始，用二项式定理就立刻可以找到导函数，这个导函数完全现成地出现在第二项中，并伴随着dc或，即一次幂的增量，加上要魔术般地丢掉的各项。这种魔术般地丢掉虽不自觉但在数学上是正确的，因为它只是丢掉了由最初的魔术一开始就产生的那个计算误差。

把∞=+4变为

2=2+d或0+，于是对这微分二项式就可象对普通的二项式一样进行处理，从技术观点来看，这是很有成效的。

唯一还可能提出的问题是：为什么把那些碍手碍脚的项用暴力镇压掉？这就是假定大家都已经知道它们是碍手碍脚的，并且实际上不属于导函数。

回答很简单：这纯粹是从经验得来的。不但对许多更加发展了的的函数，以及作为曲线方程的它们的解析形式等等，人们早已知道了实际的导函数，而且就在最先可能的决定性试验中，即在对最简单的二次代数函数的处理中发现了这一点，例如：

y=a²,y+dy=（2+d2)²=∞²+2xdx+d²,

y + y=(+)²=∞²+ 2∞+∞²。如果两边都减去原米的函数（y=2²），那末dy=2cdr+dx²，

y= 2x+；如果我从两个式子的右边镇压掉最后一项，那末

dy=2xdx，g=2a,进而得到

dy_=2,

do或

=20

安

但是从（c+a）²知道，²是第一项；第二项是2ca；如果我用α去除这表示式，犹如用dc去除上面的2cdc，或者用&去除2c，那末得到2∞作为的一阶导函数，作为二项式给∞添加的用表达的增长。因此，为了找出导函数，必须把dr或镇压掉；而根本不管dr或本来是无可奈何的。

所以，人们通过试验的方法一就在第二步中一一必然会认识到：不但为了得到一个正确的结果，甚至为了得到任何一个结果，都必须把dr或魔术般地丢掉。

其次，人们已在

2cdc+dx²或2cc+c中看到，它们是二项式（∞+dc)”或（∞+c）的正确的数学表示式（第二和第三项）。至于这个数学上正确的结果建立在数学上根本错误的假定之上，即一开始就把，-=4当作-=d或，这是人们所不知道的。不然的话，人们不用魔术般地丢掉而用最简单格式的代数运算也会获得同样的结果，并把它提供给数学界。

所以，人们自已就相信了这种新发现的算法的神秘性质。这种算法用数学上肯定是错误的方法得出了正确的（尤其在几何应用中惊人的）结果。这样，人们就把自己神秘化了，越加高估这个新发现，也就越加引起了一群旧式正统派数学家的恼怒，并激起了敌对的叫，这种叫嚣甚至在数学界以外得到了共鸣，而这也是为新事物开拓道路所必需的。

2）理性的微分演算。达兰贝尔直接从牛顿和莱布尼茨的，出发点：∞=+dc开始。但是他立刻做了-一个根本的修正：，=2+4，也就是给加上一个不确定的，但初看起来是有限的增量，他把这个增量叫做h。而这个h或4c变为dc（他和所有法国人一样，都采用莱布尼茨的写法），只是作为演化的最后结果，或者至少发生在最后一刹那之前，但神秘主义者和这种演算的创始者，却把它作为出发点（达兰贝尔本人是从符号的一边出发的，然而是在这一边变为符号之前出发的）。这样就立刻得到两种结果。

a）构成差值之比

f(c+h)-f(x）f(c+h)-f(∞)

h

2-C的出发点是

1）f（c+h）-f（x），它相应于一个用给定的代数函数，这个代数函数是在用表达的原函数例如中，以2和它的增量即c+h代替c而得出的。这种形式（如果y=f（c)，它就=y9是函数差值的形式，为了变成函数增量对自变数增量的比值，这种形式还需要进行演化，因而它起着实在的作用，不象在神秘主义者们那里仅仅起着有名无实的作用；因为，如果我象这些人那样有

f（c)=x²,

f（c+h)=（∞+h)=c²+3c²h+3xh²+h²，那末我一开始就知道，在

f（c+h)-f（∞)=x+3c²h+3xh²+h-中对立着的两边，都已归结为增量。这甚至不必写出来，因为我在右边已看到的增量=其后面的三项，同样在f（+h）一f（∞）中剩下的只是f（∞）的增量或dy。因此，这个最初的差值等式只起着一开始就重新消失的作用。这些增量一开始就处在对立的两边，如果我有了它们,那末从 dr,dy的定义我就得出

dy或是比值等等；所以为了形成或，

dr

宝，我用不到从（以+h代替∞)变化了的函数（增长了的函数）中减掉用表达的原函数而形成的那个最初的差值。

在达兰员尔那里必须抓住这个差值，因为演化运动要在它身上进行。所以，在左边处于突出地位的就不是差值的肯定表示式，即不是增量，而是增量的否定表示式，即差值，也就是f(α+h）-f(∞)。这种强调差值而不强调增量（牛顿的流数）的做法，至少在莱布尼茨所用的、与牛顿的9相对立的写法dy中，已经预感到了。

2）f(α+h)-f（∞)=3x²h+3∞h²+h²。用去除两边，便得

f(x +h)-f(x)=3x²+ 3xh+ h²。

h由此，在左边形成了

f(x+h)-f(c）f(x+h)-f(x)

h

2-3它（本身）就显现为导出的有限差值的比值，而在神秘主义者们那里，它是由dc或和dy或y的定义所给出的增量的现成的比值。

3）现在，如果在f(x+h)-f(c)f(c+h)-f(∞)

h

0

dy_而中令=0,或=,即=0,那末这表示式就变为而由于令h=0,3ch+h这两项也就同时变为0，并且确是通过正确的数学运算得到的。所以现在不用魔术就把它们消除了。我们得到：

。，d_=3x² = f′(x)。4)或

-旦变为+h，这个式子就同在神秘主义者们那里一样，已作为给定的东西存在了，因为（c+h）”代替而给出了+3r²h+etc.，其中3c²已经在这个展开级数的第二项中作为一次幂的系数出现。因此，这种推导本质上与菜布尼茨和牛顿相同，但是这个完全现成的导函数3“是用严格的代数方法从与它相联系的其余各项那里解脱出来的。这不是演化，而是把f（c），在这里就是3，从它的因子万以及与它排在一起的其余各项那里解脱出来。而实际上演化的，倒是在左面符号一边，就是dc，dy和它们的比值，即符号微系数dy_0

=（反过

0_dy更为恰当)。这个符号微系数本身还是引起了某来，=些形而上学的恐俱，尽管这个符号是用数学方法导出的。

达兰贝尔给微分演算撕下了神秘的外衣，从而向前迈进了一大步。虽然他的《流体论》已于1744年出版（参见15页0），但莱布尼茨的方法很多年来仍然在法国占着优势。至于牛顿的方法在英国一直统治到十九世纪的头几十年，这几乎是没有必要提及的。但是在这里，正象以前在法国一样，达兰贝尔奠定的基础，经过一些修改，一直到现在还占着统治地位。①见本文第10页。

3）纯粹代数的微分演算。拉格朗日，《解析函数论》（1797年和1813年）。因此在1）中和在2）中一样，最初的出发点都是增长了的；如果

y或f（c）=etc.,那末在神秘的方法中是y或f（∞+dc），在理性的方法中是y或f（c+h）（=f（∞+4c））。这个二项式出发点立刻在等式的另一边提供了一个二项式展开，例如：

2"+mxm-1h+etc.,这里的第二项m2-h已完全现成地提供了所要找的实在微系数m3m-1

a）在给定的的原函数中，当用+h代替时，左边的f（c+h）和它对面的展开级数的关系，完全象代数中未展开的一股表示式，尤其是二项式，和与它对应的展开级数的关系一样，例如，象在

（∞+h)²=c+3x²h+etc.中，（∞+h）²与其等价的展开级数c+3c²h+etc.的关系一样。因此，f（o+h）就处于同在整个代数学中一般表示式与其展开式的关系一样的代数关系（只应用于变量）之中，例如，同在

.8². 2a-=1++-

Q²+a+etca-x

a中，与展开式1+et。一样的关系之中；或同在

sin(+h）=sincosh+cossinh中，sin（c+h)与其对面的展开一样的关系之中。

达兰贝尔仅仅把（+d）或（+）代数化了，使之变为（c+h），因而f（x+h)也从y+dy，y+g变成了f（x+h)。但是，当拉格朗日把整个表示式作为一般的未展开的表示式，放在从它导出的展开级数对面时，他就给了这整个表示式一个纯粹代数的性质。

b）在第一个方法1)中和在理性的方法2)中一样，所要找的实在系数都是完全现成地由二项式定理产生出来的，而且已经出现在展开式的第二项，也就是必然附有h的项中。因此，整个往后的微分过程，无论在1）或者在2）中，都是奢侈品。所以我们把这无用的压舱物抛在一边。从二项式的展开中我们一下子就全都知道，一阶的实在微系数是的因子，二阶的是的因子等等。这些实在微系数无非是用c表达的原函数依次按二项式展开的导函数（而引进导函数这一范畴是最重要的引进之一）。就各别的微分形式而论，我们知道4c变为dc，4y变为dy，

dy，二阶导函数，即h²的系数知道一阶导函数得到符号形象d

2

d²y等等。因此，为对称起见，我们可以把这些纯得到符号形象dr?等等。因此，为对称起见，我们可以把这些纯粹用代数方法得到的结果同时也用它们的符号微分等价物来表示一这是微分演算本身唯一遗留下来的名称问题。整个实际的课题于是就化为寻找（代数）方法，“把+的各种函数按的整数升幂加以展开，而在许多情况下，没有非常见长的运算这是不可能完成的”。

到此为止，在拉格朗日那里没有什么直接从达兰贝尔方法出发不能得到的东西（因为这方法也包括了神秘主义者们的整个演化，不过是以修正的形式罢了）。

c）因此，当y的展开或f（∞+h）=etc.代替以前的微分演算的时候[这样一来，事实上清楚地暴露出了从

y+dy或y+y，c+d2或∞+c出发的那些方法的秘密，即它们的实际演化是以二项式定理的应用为基础的，因为它们一开始就对增长了的用2+dc，增长了的y用y+dy来表示，从而把单项式变为二项式]①，就会有这样一个课题：由于fc+h）在这里是没有幂次的的函数，只是它的一般的未展开的表示式，所以要从这个未展开的表示式自己，用代数方法把一般的，因而也就是对任何幂次的的函数都适用的展开级数推导出来。

为了把微分演算代数化，拉格朗日用了牛顿学派以及牛顿生前的泰勒的定理作为他的直接出发点。这个定理实际上是最一般最概括的定理，同时也是微分学的运算公式，即用符号微系数表示的y或f（a+h）的展开级数，亦即：

y或f(c+h)=y(或f(∞)）+dyh+dx²[2]dx[2.3]dr[2.3.4] +etc.。

d²yh²dyhdy_hdrd）这里要插进对于麦克劳林和泰勒定理的研究。e）拉格朗日用代数方法把f（c+h）展开成等价级数，代替

dy等等，并且只让它们作为用代数方法导来的的函泰勒的dx数的符号微分表示式而存在。（这一点以后再详细讨论。）①这对括号是在马克思的手稿里原来就有的。

初稿

牛顿：1642年生，1727年死（85岁）。《自然哲学的数学原理》（1687年初版，参见引理I和引理X1，注释）。

而后特别是《使用级数，流数的分析》，1711年第一次出版，但在1665年已经完成，而莱布尼茨于1676年才获得同样的发现。

莱布尼茨：1646年生，1716年死（70岁）。

拉格朗日：1736年生，帝制时期（拿破仑一世）才死，变分法的发明者。《解析函数论》（1797年和1813年）。

达兰贝尔：1717年生，1783年死（66岁）。《流体论》，1744年。

r）牛顿。速度或流数，例如，y等变数的速度或流数，用c，9等表示。例如，若u和是由连续运动所产生的相互联系的量（流量）；则和表示它们的增长率，因此就是它们的增量据以生成的增长率之间的比值。

由于各种各样的量的数值都可用直线表示，所以瞬或者生成量的无限水部分=它们的速度和这些速度所经历的无限小时间间隔的乘积，因此如用表示这无限小的时间间隔，那末和y的瞬就分别用t和9来表示。

例如y=uz；若9，，分别表示y，z，α增长的速度，则y，，的瞬便是9，tz，，于是我们得到：

y=u,y+g=（u+u)（2+）=uz++z+²u因此

Ty=u+2tu+²u

由于无限小，所以它会自行消失，就更不用说作为乘积的了，这不是出于无限小的时间间隔，而是它的2次方。

1

1假如=-百万，那末²=-

百万×百万。因此我们得到

y=uz+u，或者说y=uz的流数是uz+2。

2）莱布尼茨。假定要找的是uz的微分。u变为u+du，2变为z+dz；因此uz+d(uz）=（u+du)(z+dz)=uz+udz+zdu+dudz。

如果我们从这式子中减去给定的量u2，那末剩下来的是作为增量的udz+zdu+dudz；由无限小的du乘上另一个无限小的dz组成的乘积dudz，是一个二阶无限小，它的消失将先于一阶无限小udz和zdu，所以

d(uz)=udz+zdu。3）达兰贝尔。一般这样来提问题。设

y=f(x),

y=f(∞+h);要确定：当这个量消失时，二的值将变为什么，也就是说，

h0的值将变为什么。0的值将变为什么。

牛顿和莱布尼茨，以及他们的大多数继承者，一开始就在微分演算的地盘上活动，因此微分表示式一开始就当作尔后去找实在等价物的运算公式。全部奥妙就在于此。如果自变数变为2，那末因变数就变为y。但是一2必然等于某个差值，例如=h。这包含在变数概念本身之中。然而决不能由此得出这样的结论：这个=d的差值是消失着的，因而事实上就=0。它也可以表示一个有限差值。可是如果我们一开始就假定，当增长时它变为2+3（牛顿的在他对基本函数的分析中不起任何作用，所以可镇压掉），或者象莱布尼茨那样，变为3+d，那末微分表示式就立刻变为运算符号，而没有显示出它们的代数起源。

补充150（牛顿）。

对要进行微分的乘积u2，如果我们取牛顿的起始等式，那末：

y=uz,

y+y=(u+)(+)。

如果我们丢掉，就象牛顿在展开第-个微分等式之后自已所喜欢做的那样，便会得到：

y+g=（u+)(+)，y+g=uz+uz+u+，

y+y-uz=u2+u+z因此，由于uz=y，

y=uz+u+。并且为了得到正确的结果，必须把镇压掉。

那末这个要用暴力去镇压掉的项是从哪里来的呢？

非常简单，是这样来的：y的微分9，u的微分u和2的微分，一开始就是通过定义，当作与产生它们的那些变量相分开的、独立的存在而引进来的，并不是用任何一种数学方法推导出来的。

我们一方面看到，这种预先假定dy，d或y，的存在具有①指论微分>底稿中的页码。什么样的好处：一旦变数增长，我只须一开始就把二项式y+y，3+等代入代数函数中去，就可以把它们作为普通代数量来处理。

例如当y=a时，我便得到

y+y=ac+ay从而

y-ax+g=ac；因此

y=at。

这样，我立刻就得到下面的结果：因变数的微分等于α2的增长，即ac，也就是等于从a导出的实在值a（至于它在这里是个常数，那是偶然的，一点也不影响所得结果的普遍性，因为出现这种情况，只应归之于变数在这里是一次幂）乘上。如果我把这结果加以普遍化，那末我知道y=f∞），因为它表明9是一个依赖于3的变数。如果我把从fc）导出的量，也就是增量的实在元素叫做f（c），那末一般的结果便是

y=f(x)。

因此我一开始就知道，因变数y的微分的等价物，等于自变数的一阶导函数乘上它的微分，即乘上d或。

所以一般地说，如果

y=f(∞),那末

dy=f'（x)d或者=用表达的实在系数（除了因处于一次幂而出现常数的情况外）乘上。

但y=a立刻给了我y=a，而在一般情况下：

安=a，而在一般情况下：9

=f'(x)。

这样，我就给微分和微系数找到了两个进一步发展了的运算公式，它们构成了整个微分演算的基础。

此外，一般说来，由于我把先验地①假定的dx，dy等，或，等，当作&和y的独立的、孤立的增量而得到了微分演算所特有的极大好处，这就是说，变数的一切函数从一开始就可以用微分形式来表示。

如果我用这种方法对变数的一些主要的函数，如a，a3士b,αy，,",α",logr，以及初等的圆函数进行了推导，那末当

dy时，我就完全可以象算术中的乘法表那样来利用要找dy，它们。

但是，如果我们现在看一下事情的反面，那末我们立刻发现，原先的全部运算在数学上都是错误的。

我们举一个非常简单的例子：9=2。如果增长，那末它就得到一个不确定的增量，因而依赖于它的因变数？也得到了一个不确定的增量，于是我们有

y+k=(∞+h)²=x²+2hx+h²,这是由二项式定理给我们的一个公式。因此

y+k-²或y+k-y=2hx+h²；所以

（y+k）-y或k=2hx+h²如果用除两边，那末

=2c + h。

h①“先验地”-词，原文为apriori。现在令=0，就得到

2x+h=2∞+0=2∞。但另一方面，却变为；又由于仅当变为+时

k却变为；又由于仅当变为+时变为3+k，所以当h变为0，因而c+h又变为0+0，即变为∞

k_0时，y+重新变为y。因此，k也将变为0而一0"，这可用或

来表示。于是我们得到dx

或多20。0

0如果我们不这样做，而在

y+k-x²=2hc+h²或（y+k）-y=2xh-h²中令h=0（h只有事先在它的原来形式中被置为0之后才变为符号dc），那末得到k=0+0=0，而我们所获得的唯一结果，是看清楚了我们的假定：当变为+h时y才变为y+k，**所以当+h=∞+0=c时，y+k=y,或者k=0。

但是我们绝不会象牛顿所做的那样得到：

k=2xdx+dcd，或者按牛顿的写法得到：

y=2c+；只有当h经历了通过0的地狱之行以后，也就是说，在一（或（∞+h）-c）这个差值，因而-y（=（y+k）-y）这个差值也被减少到它们的绝对最小表示式-=0和y一y=0以后，才能化为，从而化为y。

但由于牛顿不是用数学推导来确定变数，3等的增量，而是立刻给它们打上了微分，9等的标记，这些增量就不能=0，否则结果势将为0，因为用代数表达的话，一开始令这些增量=0，就象上面在等式

（y+k）-y=2xh+h²中立刻令等于0，所以=0，从而最终就会得出0=0。在用除法使的一阶导函数，即这里的2，从因子h那里解放出来之前，也就是在获得

y-y=2x+h

h之前，是不充许把等于零的。只有在这以后，有限差值才能被扬弃。因此在我们能够获得微分

dy=2xd之前，原来就必须先导出微系数

dy_= 24。

dc

所以没有其他办法，只有把变数的增量h想象为无限小增量，并赋予它们以独立的存在，例如在c，y或d，dy等符号中那样。然而，无限小量和无限大量一样，也是量（无限这个词实际上只意味着不确定地小），因此这些dy，dc或y，等在计算中也起着和普通的代数量一样的作用，并且在上述等式

（y+k）-y或k=2cdc+dadc中，dxd具有和2cdc-样的存在权利。但是最使人惊奇的是用暴力把它镇压掉的那个理由，恰恰在于利用了无限小概念的相对性。dcdc要镇压掉，因为它与dc相比，从而也与2cdx或与2x相比是无限小·.···

或者，如果在

y=uz+u+u中，由于与uz和z相比是无限小而被镇压掉，那末在数学上只能这样来补救，那就是认为u2+2u.是人们愿意怎样逼近就能怎样逼近的-一个近似值。这种处理方法在普通代数里也会遇到。但这时就出现了一个更大的奇迹，即通过这种方法得到的，绝不是用表达的导函数的近似值，而是它的严格的准确值（尽管象上面那样只是符号上正确的），象在

y=2cc+2这个例子中那样。如果我们在这里镇压掉，那末就得到

y =2c和

y_=2x，正如二项式定理已经表明的那样，这是由2正确地导出的第一个导函数。

但这奇迹并非什么奇迹。如果通过暴力镇压掉而得不出准确的结果，那倒真是奇迹了。因为镇压掉的只是一个计算误差，而它却是这样一种方法不可避免的结果，这种方法把变数的不确定的增长，例如h，立刻作为微分dc或，作为现成的运算符号引了进来，从而在微分演算中一开始也就获得了一个独特的、不同于普通代数的计算方法。

我们所应用的代数方法的过程，一般可以表述如下。

设给定fx），那末首先演化出“预先导函数”，我们称之为f(x):

，或

=f(x)。1)

f²(x)=-4r从这等式得出：

y=f(c)x。因而也得出

f()=f²(∞)4∞（因为y=f（∞），4y=4f（c））。

通过令一2=0，因而y-y=0，我们得到

dy_

dz-=f'(∞)。于是

dy=f'(x)dx所以也得

df(a)=f(x)d（因为y=f（∞）,dy=df（∞））。

如果我们一旦演化出1)

△f(c)=f(),那末

2)

df(α)=f'(∞)d不过是1）的微分表示式而已。

1）如果变到，那末

A）∞-∞=由此得出下列结论：

Aa）4∞=,-∞；

a）-=∞所以，4这个和之间的差值被肯定地表示时，它是的增量；因为当重新从3中减去它时，2就回到原来状态，即回到了∞。

因此，这个差值可用两种方式来表示：直接作为增长了的变数与其增长前的状态之间的差值，这是它的否定表示式；肯定地把它作为增量①，作为结果、作为对于尚未增长时的的增①马克思在这里用铅笔加了“或减量”这几个字。量，这是肯定表示式。

我们将会看到，这种双重解释在微分演算历史中起了什么样的作用。

b）∞=+4。

∞是增长了的本身，的增长没有和它相分开；是增长的完全不确定的形式，这形式把增长了的3，即，向增长前的原来形式区别开来，但是这形式并没有把同它的增量本身相区别。因此，2，和2之间的关系只能否定地作为差值，即作为一3来表示。与此相反，在

∞=+中：

1）差值是肯定地作为的增量来表示的。

2）因此?的增长不是作为差值，而是作为处在原来状态中的本身+它的增量的和式来表示的。

3）从技术上来表述时，2将从单项式变为二项式，凡是原函数中有的任何幂次出现的地方，都要用自己和它的增量组成的二项式来代替增长了的∞，一般地说，用二项式（∞+h）"来代替”。这样，的增长的展并事实上就是二项式定理的简单应用。由于在这个二项式中是第一项，4是第二项一一这是由它们的相互关系本身所给定的，因为在增量4c产生之前就必须存在一所以事实上用二项式只是导出了的一些函数，而4则以升幂方式出现在它们的旁边作为因子，并且4的一次幂即4，应该是展开级数第二项的因子，即由二项式定理导出的2的一阶导函数的因子。当以二次幂给定时，就立刻可以看出这一点。∞²将变为（c+4c），这无非是（+4∞）和它自已相乘而给出∞²+2c4c+4²。这就是说，∞的原函数应该是第一项；²的一阶导函数，即这里的2，和因子4r一起构成第二项，而在第一项中4c仅以4°=1的形式出现。所以导函数不是通过微分而是通过应用二项式定理即通过乘法找到的，并且正是因为增长了的本身一开始就表现为二项式∞+4的缘故。

4）虽然在+4中，4就其大小而言是不确定的，象不确定的变数自己一样，但是4作为与&有区别的、与之相分离的量又是确定的，如同胎儿与怀孕前的母亲并列着一样。

+4不只是不确定地表明2作为变数有所增长，而且它表明增长了多少，即增长了4。

5）从不显现为2当应用二项式定理，也就是把+4代入2的一定幂次中而找到导函数的时候，那末整个演化就围绕着增量4进行。只是在左边，当二中的4变为

4x =0时，它最终又以=∞，一3的形式出现，以致

yyyy（_y

-（

所以-2=0这样肯定的一边，即变为=，决不能在演化中出现，因为2本身决不会出现在展开级数的一边；这样，微分演算的真正秘密也就决不会暴露出来。

6）如果y=f（∞）且y=f（c+4c），那末我们可以说，在这个方法中y的展开解决了找导函数的问题。

c）+c=（因而y+4y=y）。4c在这里只能以4=，一2的形式出现，也就是以∞，和x的差值这种否定形式，而不是象在∞，=3+4中那样作为3的增量那种肯定形式出现。

1）在这里，增长了的，即2，有别于增长前的它本身，即有别于∞，但并不是作为增长了4的∞而出现的；因此，实际上完全象一样是不确定的。

2）再者：正象出现在一个原函数中一样，作为增长了的也就出现在由于这个增长而变化了的原函数中。例如出现在函数∞中时，就出现在函数中。以前，在原函数中有出现的地方，都用（2+4）来代替，从而由二项式定理完全现成地得出了导函数，尽管这个导函数附有因子4，而且是作为附有4等因子并用表达的其他各项的先行者出现的；而现在，从也就是从增长了的的单项式这一直接形式中，就象从∞中一样，是直接推导不出什么的。但是由此给出的是差值一。我们从代数学知道，所有形如”-α的差值都可用（∞-α）除尽，在现在的情况中就是可用（∞一2）除尽。所以用，一2去除-（而不是象以前那样让（∞+4c）按函数的给定幂次自乘若干次），我们就获得一个形如（-∞）P的表示式，不管的原函数是多项式（即含有的不同幂次），还是象在我们这例子中那样是单项式，在这里都不会有什么改变。通过除法，这个(一)变为左边-y的分母，因而产生了二这个用抽象

∞,-∞的差值形式表示的函数的差值和自变数2的差值之比。要把用，表达的函数和用表达的函数之间的差值分解成都含有（一2作为因子的各项，就要根据的原函数的性质，或多或少用到一些代数技巧，不会总是象在一3”中那样容易。但这在方法上并没有什么改变。

凡是原函数按其性质不能直接分解为（-c）P的地方，如f（∞）=uz（两个依赖于c的变数）就是这样，（2，一c）便出现在因子一一-中。再者，用（x－）去除两边而在左边把它消掉以

,-后，如果在P中还保留有一2的话（例如对y=a求导时，我们求得y-y=α（a-1)+(x-）-1

(a -- 1)² + ete.{

1.2

-2若在这里令∞,-=0，则得

1-(a-1)²-etc.

(a-1)-1-(a-I)²+-(a-1)²-etc.=a

2

3那末象在刚才引用的例子中那样，总是只能这样做：通过令3一0=0来使它消失，从而在它的位置上总会留下一个肯定的结果。换一句话说，在P中还保留下来的∞，一是不可能作为因子（作为乘数）与P的其他成份联结在一起的。不然的话，就可把P分解成P=p（∞-∞），而由于已令∞-2=0，它就变成p·0因而P=0....·

如果y=∞从而y=∞，那末一阶有限差值-c就演化成

y1-y=(∞-)P,于是

y-y=P。

-2P这个由和组成的表示式=f，也就是一阶有限差值的导函数，其中一象高次幂（∞-∞）²等等一样已被消去。因此,和只能结合在象+，，，

，√等等这样一些肯定的表示式中。所以如果现在令∞，=3，那末这些表示式就相应地变为2,2²，或1,√z或等等,而只是在&-作为分母的左边才出现0，因面才出现符号微系数等等。

续 稿c）续25页①。

我们原先把∞-=4当作差值∞一∞的表示式；这个差值在这里只是在它的形式上作为差值而存在（正象当3为的因变数时，通常都写成一y）。通过令∞，一0=4，我们就给了这个差值一个与它本身不同的表示式。即使用的是不确定的形式，我们还是把这个差值的数值作为与这个差值本身不同的量来表示。例如4-2是4和2的差值的纯粹表示式：但是4-2=2是用（右边的）2表示的差值：a）因而在肯定的形式中，它已经不再作为差值；b）当减法已做完，差值已算出，4-2=2就给我提供了4=2+2。第二个2在这里以原来的2的增量的肯定形式出现，因而直接以一个与差值形式相对立的形式出现，（正如a-b=c,α=b+c，其中c表现为6的增量；又如∞==4∞，=+4x，其中4直接表现为的增量。）

原先仅仅设置，一=4=某个东西的做法，也就设置了代替差值形式的另-个形式，即和的形式=2+4，同时把只表示差值的，一看作是这个差值的，即量4的数值等价物。

同样，从-∞=4c可以得到-4=∞。这里，我们在左边又有一个差值形式，但这是作为增长了的和它自已的、独立地出现在它旁边的增量之间的差值形式。和的增量4之间的差值是这样的一个差值，它虽然不确定，但现在已表示的一个确定值。①指微分演算的历史发展过程<初稿>中的页码，相当于本文第17页。

然而如果从神秘的微分演算出发，在那里一立刻以-=dv的形式出现，又如果一开始就把dc修正为4，那末这就是从-=4出发，因而也就是从=∞+4出发；但是这式子本身又可以转变为3+4c=1，以致3的增长又获得不确定的形式，而且作为这样的增长直接出现在微分演算中。这就是我们所应用的代数方法的出发点。

d）从这些简单的形式上的差别，立刻产生了对待微分演算的一个根本差别。这个根本差别，我们在分析达兰贝尔方法时已经详细指出（见所附的几张活页）。这里只是一般地作些评述。

1）如果差值2，一2（因而9一y）立即作为它的对立物，作为和式=+4c出现，因而其数值大小立即以增量4x的肯定形式出现，那末当在用表达的原函数中处处以3+4代替时，就要展开一定幂次的二项式，而，的演化便变为二项式定理的应用。二项式定理无非是一次的二项式自乘m次后所给出的表示式的一般表述。因此，如果我们一开始就把差值表示为它的对立物，即表示为和式，那末乘法就成了3，（即3+4）的演化方法。

2）由于在一般的表示式=+4中，处于肯定形式4，即增直形式下的差值，一2是这表示式的后一项或第二项，所以，一旦用表达的原函数换成用3+4表达的函数，就是它：的第一项而4是第二项。但是我们从二项式定理知道，这第二项伴随着第一项只表现为升幂的因子，表现为乘数，因而用表达的（由二项式的幂次决定的）第一个表示式的因子是（4）°=1，第二项的乘数是（4），第三项的是（4）²等等。因此以增量的肯定形式表示的差值，只是作为乘数而出现，而且是在二项式（2+4c）”展开的第二项中（由于（4c)°=1）第一次实际上作为乘数而出现。

3）另一方面，如果我们现在来看用本身表达的函数的展开，那末二项式定理就为这里的第一项，给我们提供了连串导函数。例如，如果我们有（c+h），在这代数二项式中，是已知量，是未知量，那末我们得到

∞+4∞h+etc.,因此，处于第二项中的、并以h的一次幂为其因子的4，是2的一阶导函数，或者用代数方法来表述：如果我们有二项式（x+h）的未展开的表示式，那末它的展开级数给我们提供了4o作为的第一个增长（作为它的增量），它作为的系数而出现。但如果是个变量，且我们有f（x）=，那末这函数将由于它的增长本身变为f（∞+h），或者在第种形式下变为：

f(+）=（∞+)=∞+4∞²4+etC.在普通的代数二项式（+)中，2是作为这二项式的第一项给出的；而在变数的二项式表示中，亦即在（∞+4）中，这∞现在就显现为增长并且变为+4之前用表达的原函数的再生产。由二项式定理的本性，我们一开始就很清楚，如果fo）=变为f（∞+h）=（+h)，那末（∞+h）的第一项等于∞，亦即必须=用表达的原函数：（c+h）必须包括两部分，即用表达的原函数（这里是∞）+因∞变为（∞+h）*而得来的一切附加项，因此二项式（c+h）的第一项....

4）再者，二项式展开的第二项4c%立刻完全现成地给我们提供了的一阶导函数，即4。所以这种推导是通过

f(α+4∞)=（+△∞)的展开而获得的，是通过把差值，一3一开始就表示为它的对立物，表示为和式2+4而获得的。

所以由于∞增长而从f（c）获得的f（α+4c）或y的二项式展开，给我们提供了一阶导函数，它是（二项式级数中）h的系数，而且就在二项式展开的开头，即在其第二项中。因此，这种推导决不是通过取差值得来的，而是直接通过把f（c+h）或9展开成一个确定的、由简单乘法产生的表示式而得来的。

因此这方法的关键，在于把不确定的表示式3或f（c+h）展开成确定的二项式形式，而绝不是把∞一，从而也不是把y一y或f（c+h）一f（∞）作为差值来加以展开。

5）由于我们立刻得到f（c+4）=（∞+△∞）=∞+4∞+6∞²4x²+4x+∞²，所以这方法中出现的唯一的差值等式，如果我们把它写下的话，就是

+4c+6x²x²+44+4-∞，也就是把级数开端的原函数在后面重新减掉，于是在我们的面前就出现一个增量，它是用表达的原函数通过二项式展开而得到的。因此牛顿也是这样写的。所以我们得到增量

4°+6∞²²+4xA+x，即原函数的增量。因而我们在对立的一边就不需要任何一种差值了。当

y或f（∞）=∞时，相应于的增量有y的增量。因而牛顿也立刻写为：

dy，在他那里是y=4x+ctc.。

6）此后的整个演化，就在于把完全现成的导函数4o°从其因子4和各相邻项那里解放出来，从其环境中摆脱出来。所以这个方法不是演化法面是解脱法。

θ）（作为一般表示式的）f（x）的微分。

首先我们指出，“导函数”这个概念作为符号微系数的逐次实在等价物，是微分演算原先发明人及其最初继承者们所完全不知道的，事实上首先是由拉格朗日引进的。在前者那里，只有因变数例如9才显现为x的函数，它完全相应于函数的原来代数意义，这种函数最初用于未知数多于方程个数的那些所谓不定方程，所以在那里随着取不同的值，例如？也就取不同的值。但在拉格朗日这里，原函数是应予微分的、的确定的代数表示式；因此，如果y或f（c）=，那末2是原函数，4是-阶导函数等等。所以为避免混乱起见，应把因变数y或者fc）称为x的函数，而相反地把拉格朗日意义下的原函数称为用x表达的原函数，并相应地把那些“导”函数称为用×表达的“导”函数。

在代数方法中，我们首先演化出预先导函数或有限差值之比力，而后才由此导出最终导函数厂。在这个方法中我们一开始就知道：f（∞）=y，所以a）4f（c）=4y，因而反过来4y=4f（c）。于是首先要演化的，恰恰是4f（c），即f（∞）的有限差值。

我们求得：

，所以=f(x)。f²(x)=2

4x，

r因而也得：

y=f²（x）c，并且由于4y=4f（c），所以

Af(x）=f²(c)△∞。这微分表示式的进一步演化，给我们最后提供了

df(x)=f'(c)dx,它不过是以前演化得到的有限差值的微分表示式而已。

在普通方法中，

dy或df（∞）=f（c)do根本不是演化得来的，而是如上所见，只是把由二项式（c+4c）或（c+dc）完全现成地提供的f（c）从它的因子和相邻各项那里解脱出来。达兰贝尔方法分析

关于极限a）（c+h)=∞+3hx²+3h²c+hb)（x+h)-x=3c²h+3xh²+h²；

=3x²+3ch+h²。c）（x+h)-∞²

h如果h变为=0，那末

x-x

0(+0)-∞或-0

，而其右边=3∞²，因此

或da

00

dy=3²dc

y=c， y=x；-g=-∞=(-)(²+∞+∞²)；

dyy-y或dr

=2²++²-C

dy.=3x²

dx=3x²Ⅱ）如果我们令∞-=h，那末：1)(-x)(∞²++∞²）=h（x²+x+∞²）2）因此

y—y =+xx+x。

h在1）中，h的系数不是象上面f那样的现成导函数，而是

，而是f1；所以用去除两边，给出的也不是dx

或

=0²+ x+2等等，等等。

如果在Ie）的另一边，即在

f(α+h)-f(±)或=3x²+ 3ch+h²

h

h中，我们从这样一种想象出发，以为右边h的值越减少，3ch+这两项的值就会越加减少，因而整个右边的值3c+3ch+h也就越来越接近于值3c：那末我们必须补充一句：无论什么时候都不会同它相吻合。

这样，3r²就成为级数3c²+3ch+h²能够不断接近，但永远不能达到，因而更不能超过的一个值。在这个意义下，3c变成级数3c+3ch+h²的极限值。

另一方面，量或y1-y

也将随着分母k的减少在

-而越来越减少。但因-是3x²+3αh+h²的等价物，所以这

h

一级数的极限值就是它本身的极限值，正象在同样意义下这个fa

极限值就是与它等价的级数的极限值一样。

但是一旦我们令h=0，那末右边的各项就此消失，而使3t1l1t1

成为右边的值的极限；3c现在是∞的一阶导函数，因而=f（c）。作为f（x）它表明：从它又可以导出f”（c）（在当前情况下=6c）等等；因而增量f（∞）或3²不等于从展开f（∞）=∞²而得到的那些增量之和。假如f（c）本身是一个无穷级数，那末从它展开面得到的增量的级数自然也是无穷级数。而在这个意义下，

月一旦我把展开得来的增量的级数截断，就变为它的展开的极限值，从而在这里就变为一个通常代数或通常算术意义下的极限值，正如一个无限十进位小数的展开部分是它可能的展开的极限，是一个在实践或理论中够用了的极限。这和第一种意义下的极限值绝对没有共同之处。

在这里第二种意义下的极限值可以随意使之增大，而在那里则只能减少。再者，只要飞在减少，

y-y-y-y

孔

-2

0只会接近于表示式一；后者是它永远达不到而更不能超过的极

U限，在这情况下可以把巴一看作是它的极限值。

0但是旦变为=

0_dy

，后者就不再是的极五

h限值，因为它自己在本身的极限中已消失了。关于它先前的形式或，我们只能说，

0是它的绝对最小表示式，

C-C

h孤立地看，这个绝对最小表示式不是一个数值表示式；但是现在或ay）有3r²即f（∞)在其对面作为它的实在等价物。

或）有3r²即f（∞)在其对面作为它的实在等价物。这样一来，在等式

0或录=f'（∞）

dy=f'（∞）

0的两边，没有一边是另一边的极限值。它们之间没有极限关系，而有等价关系。

非是2

=2，那末既非2是的极限，亦非如果我有

3

3的极限。一个量的值=它的值的极限这种说法，只能导致淡而无味的同义反复。

因此，极限值概念是可能被曲解的，而且经常被曲解。应用到微分等式时，它作为准备令3一2或h=0的、并使之成为更能想象的手段，是一种幼稚行为，这种行为来源于最初神秘的和故弄玄虚的微分演算方法。

在微分等式对曲线等等的应用中，极限值概念确实起着几何上直观化的作用。

达兰贝尔方法和代数方法的比较我们把达兰贝尔方法同代数方法作一比较。I）f(x）或y=∞²；a）f（x+h)或y=（∞+h)=∞+3∞²h+3∞h²+hbb)f（∞+h)-f（∞)或y-y=3o²h+3ch²+h；

f(x+h)--f(x)或-=3x²+3xh+h²；）

h

h当h=0时，

dy_ =3x²=f′(a)。

0或品d）0II)f()或y=∞²;a）f(∞）或y1=∞]；b）f（x）-f（x）或y-=∞²-∞²=（∞∞）（∞²+∞+∞²）；

f(x）-f(x)或²++∞²c）

22

-²++∞²如果∞，变为=∞，那末∞,一=0，因此

cby

。或品一（∞²+x+x²）=3∞²d)

0

在两种方法中，这样一点是相同的：如果自变数增长，那末因变数y也增长。整个问题在于如何表示的增长。如果变为∞，那末-=4c=h（这是一个不确定的、可以无限缩小而总是有限的差值）。

或是增长的增量，因为：8）=∞+4c，但也可以反过来b）+c或c+h=。

历史上微分演算是从&）出发的，也就是说从下面一点出发的：差值4或增量h（两者都表示同-个东西，一个是否定地作为差值4，另一个是肯定地作为增量h）在量x的旁边独立地存在着，它就是的增量，表示已增长，而且增长了h。由此一开始就得到了好处，那就是一旦这个变数增长，那末相应于这个一般表示式的变数的原函数，就可用一定幂次的二项式来表示，因而二项式定理一开始就可应用于它。事实上在一般的一边即左边，我们已经有一个二项式，即∞+4c或y=etc.。

神秘的微分演算立刻把（+4c）变为（+dc），或者在牛顿那里变为+。这样一来，我们在右边即代数的一边也立刻得到了用+dv或+表达的二项式，而后它们就被当作普通的二项式来处理。把4变为dv或的这种做法，数学上不加拒绝而先验地①假定下来，因此后来就有可能把二项式展开的一些项神秘地镇压掉。

达兰贝尔从（c+dc）出发，但是他把这表示式改正成为（+4c）或者（x+h）；现在需要有一个使4c或h变为dc的演化，而这也就是实际所发生的全部演化。

不管是错误地从（+dc）出发，还是正确地从（+h）出发，把这个不定二项式代入2的给定的代数函数中，它就变为一个具有一定幂次的二项式，犹如在Ia）中代替c出现了（∞+h）并且实际上就变为这样一个二项式，它在一种情况下以d而在另一种情况下以作为它的后一项，因而在展开中也只是作①“先验地”一词，原文为apriori。为因子外在地侬附于那些通过二项式导出的函数。

因此我们在1a）中立刻现成地找到了2*的一阶导函数，它就是3x²，就是级数第二项中附有h的系数。从此以后，3c²=户（）就不再改变。它本身决不是由任何一种微分过程推导得来的，而是一开始就由二项式定理所提供的，并且这确实是由于我们一开始就把增长了的表示为二项式

+4=2+h,即表示为增长了的。现在的整个课题，就在于使这个似乎不是处于发育之中的而是完全现成的f（∞），从它的因子h及其他各附带项那里摆脱出来。

在ILa）中则与此相反，增长了的进入代数函数在形式上完全象原先进入其中一样；变为v。通过相继的2次，而且是两次性质完全不同的微分运算，才能最后得到导函数f（c）。

在等式Ib)中，差值f(∞+h）-f(∞)或y-y的确为符号微系数的形成做好了准备；对于实在微系数，这个差值只是使它从级数的第二位移到第一位，因而使它得以从五那里解放出来，此外没有任何改变。

在Ib）中，我们两边都得到差值表示式，在代数的一边，对差值作这样的演化，使得（一2）作为因子出现在一个用和，表达的导函数的旁边，而这个导函数是用∞一去除-2得来的。只有差值一存在，才有可能把它分解成两个因子。由于

2-3=h,所以∞-2分解成的两个因子也可以写成h（x²+∞3+∞²）。这表明了与Ib）的一个新的差别。h本身作为预先导函数的因子，只是通过差值一2演化为两个因子的乘积才被推导出来的；面h作为“导函数”的因子，如在1a）中那样，则是在任何一个差值形成以前就已现成地存在着的。至于从变到，的不定增长采取与并列的因子h这种分离的形式，在1中一开始就被假定了下来，在Ⅱ）中则是（由于∞-2=h）通过推导而得到证明的。在1中虽然一方面是不确定的，但另一方面，就的不定增长已显现为一个固有的量，就增长了这样一个量，因而它能和并列地出现而论，却又是确定的。

在Ie)中，现在要把f（c）从它的因子h那里解放出来；这

f(x+b)-f(α）,因而也得到微样，我们在左边得到或

h

h系数的一个仍然有限的表示式。但另一方面，当我们把=0代f(∞+h)-f(x)从而使它变为=时，我们在Id）中一边

Q.dy时，我们在Id）中一边入

h得到符号微系数，另一边得到f（c），它在la）中已现成地存在，而现在则摆脱了其余各项而单独地出现在右边。

积极的演化只发生在左边，因为符号微系数是在这里产生出来的。在右边，这个演化仅仅在于使[a）中已通过二项式找到的f（α）=3x²，从它原先的附属物那里解放出来。h变为0或，一2=0在右边只具有这种消极的意义。

在Ⅱc）中则与此相反，通过，-2（=h）除两边，首先得到一个预先导函数。

最后在IId）中，由于肯定地令=&，就得到最终导函数。然而这个，=同时意味着令-2=0，因而使左边有限的比值

变为或

dy91-g

0∞-2

在1中象在神秘的微分法中一样，“导函数”很少是通过令-2=0或h=0而找到的。在这两种情况中都是为一开始就现成地出现的f（）扫除掉附带的各项。不过，现在数学上是正确的，而在那里则采取了一次政变。

描述：

